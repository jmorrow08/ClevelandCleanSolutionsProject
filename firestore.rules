rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isLoggedIn() {
      return request.auth != null;
    }
    
    function hasClaim(role) {
      return request.auth != null && request.auth.token != null && request.auth.token[role] == true;
    }
    
    function isOwner() {
      return hasClaim('owner');
    }
    
    function getUserData(userId) {
      return exists(/databases/$(database)/documents/users/$(userId)) ?
             get(/databases/$(database)/documents/users/$(userId)).data : null;
    }
    
    function hasRoleInFirestore(userId, role) {
      let userData = getUserData(userId);
      return userData != null && userData.role == role;
    }
    
    function isProfileOwner(profileDocId) {
      return isLoggedIn() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData(request.auth.uid).profileId == profileDocId;
    }
    
    function isResourceOwner(userId) {
      return isLoggedIn() && request.auth.uid == userId;
    }

    // --- users Collection Rules ---
    match /users/{userId} {
      // Allow users to read their own document without requiring custom claims (for login flow)
      // OR admin/owner to read any document
      allow read: if isLoggedIn() && (request.auth.uid == userId || hasClaim('admin') || isOwner());
      allow create: if false; // Cloud Functions handle creation
      allow update: if hasClaim('admin') || hasClaim('super_admin') || isOwner(); // Only admins/owners can update user docs directly
      allow delete: if false; // Deletion handled by Cloud Function
    }

    // --- clientMasterList Rules ---
    match /clientMasterList/{clientDocId} {
      function clientCanUpdateProfileFields() {
        let allowedKeys = ['contactName', 'phone', 'updatedAt'];
        return request.resource.data.contactName is string && request.resource.data.contactName.size() > 0 &&
               request.resource.data.phone is string &&
               request.resource.data.updatedAt is timestamp &&
               request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedKeys);
      }

      function isClientEmailMatch() {
        return isLoggedIn() && request.auth.token.email == resource.data.email;
      }

      // Allow reading for clients by email match or profile ownership
      allow read: if hasClaim('admin') || isOwner() || 
                     (hasClaim('client') && isProfileOwner(clientDocId)) || 
                     isProfileOwner(clientDocId) ||
                     isClientEmailMatch();
      allow create: if hasClaim('admin') || isOwner();
      allow update: if hasClaim('admin') || isOwner() ||
                       (hasClaim('client') && isProfileOwner(clientDocId) && clientCanUpdateProfileFields()) ||
                       (isClientEmailMatch() && clientCanUpdateProfileFields());
      allow delete: if hasClaim('admin') || isOwner();
    }

    // --- employeeMasterList Rules ---
    match /employeeMasterList/{employeeDocId} {
      function employeeCanUpdateProfileFields() {
        let allowedKeys = ['phone', 'firstName', 'lastName', 'updatedAt'];
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedKeys) &&
               request.resource.data.updatedAt is timestamp;
      }

      function isEmployeeEmailMatch() {
        return isLoggedIn() && request.auth.token.email == resource.data.email;
      }

      // Allow reading for admins, owners, or the employee themselves
      allow read: if hasClaim('admin') || isOwner() || 
                     (hasClaim('employee') && isProfileOwner(employeeDocId)) ||
                     (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isProfileOwner(employeeDocId)) ||
                     isEmployeeEmailMatch();
      allow create: if hasClaim('admin') || isOwner();
      allow update: if hasClaim('admin') || isOwner() ||
                       (hasClaim('employee') && isProfileOwner(employeeDocId) && employeeCanUpdateProfileFields()) ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isProfileOwner(employeeDocId) && employeeCanUpdateProfileFields());
      allow delete: if hasClaim('admin') || isOwner();
    }

    // --- locations Collection Rules ---
    match /locations/{locationDocId} {
      function isLocationClient() {
        return isLoggedIn() && 
               exists(/databases/$(database)/documents/clientMasterList/$(resource.data.clientProfileId)) &&
               get(/databases/$(database)/documents/clientMasterList/$(resource.data.clientProfileId)).data.email == request.auth.token.email;
      }

      allow read: if hasClaim('admin') || isLocationClient() || isLoggedIn();
      allow create, update, delete: if hasClaim('admin');
    }

    // --- servicePhotos Collection Rules ---
    match /servicePhotos/{photoId} {
      function isValidPhotoData(photoData) {
        let userDocData = getUserData(request.auth.uid);
        return isLoggedIn() && 
               userDocData != null &&
               (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee')) &&
               photoData.employeeProfileId == userDocData.profileId &&
               photoData.locationId is string && photoData.locationId != '' &&
               photoData.photoUrl is string && photoData.photoUrl.matches('https://firebasestorage.googleapis.com/.*') &&
               photoData.uploadedAt is timestamp;
      } // REMOVED ; from end of function block

      function employeeCanUpdatePhotoNotes() {
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['notes', 'updatedAt']) &&
               request.resource.data.notes is string &&
               request.resource.data.updatedAt is timestamp;
      } // REMOVED ; from end of function block

      function isPhotoOwner() {
        let userDocData = getUserData(request.auth.uid);
        return userDocData != null && resource.data.employeeProfileId == userDocData.profileId;
      }

      allow create: if isValidPhotoData(request.resource.data);
      function isPhotoClientByEmail() {
        return isLoggedIn() && 
               exists(/databases/$(database)/documents/locations/$(resource.data.locationId)) &&
               exists(/databases/$(database)/documents/clientMasterList/$(get(/databases/$(database)/documents/locations/$(resource.data.locationId)).data.clientProfileId)) &&
               get(/databases/$(database)/documents/clientMasterList/$(get(/databases/$(database)/documents/locations/$(resource.data.locationId)).data.clientProfileId)).data.email == request.auth.token.email;
      }

      allow read: if hasClaim('admin') || isOwner() || hasClaim('client') ||
                     (hasClaim('employee') && isPhotoOwner()) ||
                     (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isPhotoOwner()) ||
                     (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'client')) ||
                     isPhotoClientByEmail();
      allow update: if hasClaim('admin') || isOwner() ||
                       (hasClaim('employee') && isPhotoOwner() && employeeCanUpdatePhotoNotes()) ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isPhotoOwner() && employeeCanUpdatePhotoNotes());
      allow delete: if hasClaim('admin') || isOwner() ||
                       (hasClaim('employee') && isPhotoOwner()) ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isPhotoOwner());
    }

    // --- employeeTimeTracking Rules ---
match /employeeTimeTracking/{entryDocId} {
  // Helper to check if the logged-in user's profileId from /users collection
  // matches the employeeProfileId stored in the time tracking document.
  function isTimeEntryOwner() {
    let userDocData = getUserData(request.auth.uid); // Use existing helper
    return userDocData != null && resource.data.employeeProfileId == userDocData.profileId;
  }

  // Helper to check if the data being created is valid AND
  // if the employeeProfileId being written matches the creator's own profileId.
  function isValidTimeEntryDataForCreate(entryData) {
    let userDocData = getUserData(request.auth.uid);
    return isLoggedIn() &&
           hasRoleInFirestore(request.auth.uid, 'employee') && // User's role in /users is 'employee'
           userDocData != null &&
           entryData.employeeProfileId == userDocData.profileId && // Creating for themselves
           entryData.locationId is string && entryData.locationId != '' &&
           entryData.status is string && entryData.status == "Clocked In" &&
           entryData.clockInTime is timestamp &&
           entryData.clockOutTime == null &&
           (entryData.clockInCoordinates == null || entryData.clockInCoordinates is latlng) &&
           entryData.createdAt is timestamp &&
           entryData.updatedAt is timestamp;
  }

  // Employees need to update their own entries to clock out
  function employeeCanClockOut(updatedEntryData) {
    let userDocData = getUserData(request.auth.uid);
    // Check that they are only modifying specific fields for clock-out
    let allowedUpdateKeys = ['clockOutTime', 'status', 'clockOutCoordinates', 'updatedAt'];
    return isLoggedIn() &&
           hasRoleInFirestore(request.auth.uid, 'employee') &&
           userDocData != null &&
           resource.data.employeeProfileId == userDocData.profileId && // Must own the record
           updatedEntryData.status == "Clocked Out" &&
           updatedEntryData.clockOutTime is timestamp &&
           (updatedEntryData.clockOutCoordinates == null || updatedEntryData.clockOutCoordinates is latlng) &&
           updatedEntryData.updatedAt is timestamp &&
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedUpdateKeys);
  }

  allow read: if hasClaim('admin') || isOwner() ||
                (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isTimeEntryOwner());

  allow create: if hasClaim('admin') || isOwner() || isValidTimeEntryDataForCreate(request.resource.data);

  // Allow admin to update anything. Allow employee to update ONLY for clocking out.
  allow update: if hasClaim('admin') || isOwner() || employeeCanClockOut(request.resource.data);

  allow delete: if false; // Or if hasClaim('admin') if needed
}

    // --- serviceHistory Rules (SIMPLIFIED UPDATE RULE v2) ---
    match /serviceHistory/{jobDocId} {
      function isAssignedEmployee() {
         // Check if user is an employee AND assigned to this job
         let userDocData = getUserData(request.auth.uid);
         return isLoggedIn() &&
                userDocData != null &&
                (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee')) &&
                resource.data.employeeAssignments is list &&
                resource.data.employeeAssignments.filter(__item__, __item__.employeeId == userDocData.profileId).size() > 0;
      } // REMOVED ; from end of function block

      function isJobClient() {
        let userDocData = getUserData(request.auth.uid);
        return isLoggedIn() &&
               ((userDocData != null &&
                 userDocData.profileId == resource.data.clientProfileId &&
                 ((hasClaim('client')) || (hasRoleInFirestore(request.auth.uid, 'client')))) ||
                (exists(/databases/$(database)/documents/clientMasterList/$(resource.data.clientProfileId)) &&
                 get(/databases/$(database)/documents/clientMasterList/$(resource.data.clientProfileId)).data.email == request.auth.token.email));
      }

      function isValidServiceHistoryData(jobData) {
        return jobData.clientProfileId is string && jobData.clientProfileId != '' &&
               jobData.locationId is string && jobData.locationId != '' &&
               jobData.serviceDate is timestamp &&
               (jobData.employeeAssignments == null || jobData.employeeAssignments is list) &&
               jobData.status is string && jobData.status != '' &&
               jobData.createdAt is timestamp &&
               jobData.updatedAt is timestamp;
      } // REMOVED ; from end of function block

      allow read: if hasClaim('admin') || isJobClient() || isAssignedEmployee();
      allow create: if hasClaim('admin') && isValidServiceHistoryData(request.resource.data);
      allow update: if request.auth != null && request.auth.token.admin == true;
      allow delete: if hasClaim('admin');
    } // <<< End serviceHistory match

    // --- employeeRates Rules ---
    match /employeeRates/{rateId} {
      allow read, write, delete: if hasClaim('admin');
    }

    // --- employeePayroll Rules ---
match /employeePayroll/{payrollDocId} {
  // Helper to check if the logged-in user's profileId from /users collection
  // matches the employeeProfileId stored in the payroll document.
  function isPayrollOwner() {
    let userDocData = getUserData(request.auth.uid); // Use existing helper
    return userDocData != null && resource.data.employeeProfileId == userDocData.profileId;
  }

  allow read: if hasClaim('admin') ||
                (isLoggedIn() &&
                 hasRoleInFirestore(request.auth.uid, 'employee') &&
                 isPayrollOwner()); // Employee can read their own payroll doc

  allow update, delete: if hasClaim('admin'); // Only admins can modify/delete
  allow create: if false; // Only Cloud Function creates
}

    // --- generalJobNotes Collection Rules ---
    match /generalJobNotes/{noteId} {
      function isValidJobNoteData(noteData) {
        let userDocData = getUserData(request.auth.uid);
        return isLoggedIn() && 
               userDocData != null &&
               (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee')) &&
               noteData.employeeProfileId == userDocData.profileId &&
               noteData.locationId is string && noteData.locationId != '' &&
               noteData.notes is string && noteData.notes != '' &&
               noteData.createdAt is timestamp;
      }

      function isNoteOwner() {
        let userDocData = getUserData(request.auth.uid);
        return userDocData != null && resource.data.employeeProfileId == userDocData.profileId;
      }

      allow create: if isValidJobNoteData(request.resource.data);
      allow read: if hasClaim('admin') ||
                     (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isNoteOwner()) ||
                     (hasClaim('employee') && isNoteOwner());
      allow update: if hasClaim('admin') ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isNoteOwner()) ||
                       (hasClaim('employee') && isNoteOwner());
      allow delete: if hasClaim('admin') ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isNoteOwner()) ||
                       (hasClaim('employee') && isNoteOwner());
    }

    // --- counters Collection Rules ---
    match /counters/ids {
      allow read: if hasClaim('admin');
      allow write: if false; // Only Cloud Function modifies
    }

  } // End match /databases/{database}/documents
} // End service cloud.firestore